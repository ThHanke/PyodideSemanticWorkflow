# Generic Activity Generation from Workflow Templates

This document describes the **generic, template-agnostic** rules for generating PROV-O activity instances from P-Plan workflow templates. These rules work for workflows with any number of steps.

## Core Principle

**Everything needed to generate activity instances must be derivable from the template using standard SPARQL queries.** No manual intervention or workflow-specific logic should be required.

## Template Structure (P-Plan Standard)

### Key Pattern for Multi-Step Data Flow

```turtle
# Variable that is BOTH output of Step A AND input of Step B
?intermediateVar a p-plan:Variable ;
    p-plan:isOutputVarOf ?stepA ;
    p-plan:isInputVarOf ?stepB .
```

This single pattern enables automatic derivation of:
1. **Step ordering**: Step A must execute before Step B
2. **Data flow**: Output entity from Activity A becomes input to Activity B
3. **Dependencies**: Step B depends on Step A

## Generic Derivation Rules

### Rule 1: Identify All Steps in Order

**SPARQL Query:**
```sparql
PREFIX p-plan: <http://purl.org/net/p-plan#>

# Find all steps and their dependencies
SELECT ?step ?dependsOnStep WHERE {
    ?step p-plan:isStepOfPlan ?plan .
    
    # Optional: find dependencies via shared variables
    OPTIONAL {
        ?variable p-plan:isOutputVarOf ?dependsOnStep ;
                  p-plan:isInputVarOf ?step .
        FILTER(?step != ?dependsOnStep)
    }
}
ORDER BY ?dependsOnStep ?step
```

**Result**: Complete step execution order based on data dependencies.

### Rule 2: Find Resources for Each Step

**SPARQL Query:**
```sparql
PREFIX prov: <http://www.w3.org/ns/prov#>
PREFIX p-plan: <http://purl.org/net/p-plan#>

# Get code and requirements for a specific step
SELECT ?step ?resource WHERE {
    ?step p-plan:isStepOfPlan ?plan ;
          prov:used ?resource .
}
```

**Generation Rule:**
```
FOR EACH step IN workflow:
    activity.prov:used = step.prov:used  # Inherit resources
```

**This is why** `prov:used` is declared on the Step in the template!

### Rule 3: Find Input Variables for Each Step

**SPARQL Query:**
```sparql
PREFIX p-plan: <http://purl.org/net/p-plan#>

# Get all input variables for a step
SELECT ?step ?inputVar ?isIntermediateData WHERE {
    ?inputVar p-plan:isInputVarOf ?step .
    
    # Check if this is intermediate data (output from another step)
    BIND(EXISTS {
        ?inputVar p-plan:isOutputVarOf ?otherStep .
        FILTER(?otherStep != ?step)
    } AS ?isIntermediateData)
}
```

**Generation Rule:**
```
FOR EACH inputVar WHERE inputVar.isInputVarOf(step):
    IF inputVar.isOutputVarOf(previousStep):
        # This is intermediate data - find the entity generated by previousStep
        entity = FIND entity WHERE:
            entity.prov:wasGeneratedBy = activityForPreviousStep
            entity.p-plan:correspondsToVariable = inputVar
        activity.prov:used = entity
    ELSE:
        # This is workflow input - user must provide concrete data
        entity = userProvidedEntity WHERE:
            entity.p-plan:correspondsToVariable = inputVar
        activity.prov:used = entity
```

### Rule 4: Generate Output Variables

**SPARQL Query:**
```sparql
PREFIX p-plan: <http://purl.org/net/p-plan#>

# Get output variables for a step
SELECT ?step ?outputVar WHERE {
    ?outputVar p-plan:isOutputVarOf ?step .
}
```

**Generation Rule (executed by Python script):**
```
FOR EACH outputVar WHERE outputVar.isOutputVarOf(step):
    entity = ExecuteStep(activity, inputs)
    entity.p-plan:correspondsToVariable = outputVar
    entity.prov:wasGeneratedBy = activity
```

### Rule 5: Link Activities via prov:wasInformedBy

**SPARQL Query:**
```sparql
PREFIX p-plan: <http://purl.org/net/p-plan#>

# Find which steps should be linked
SELECT ?stepA ?stepB ?sharedVariable WHERE {
    ?sharedVariable p-plan:isOutputVarOf ?stepA ;
                    p-plan:isInputVarOf ?stepB .
    FILTER(?stepA != ?stepB)
}
```

**Generation Rule:**
```
IF stepB uses output from stepA (via shared variable):
    activityB.prov:wasInformedBy = activityA
```

## Complete Generic Algorithm

### Pseudocode

```python
def generate_workflow_execution(plan_uri, user_inputs):
    """
    Generate complete workflow execution for ANY plan.
    
    Args:
        plan_uri: URI of the p-plan:Plan to execute
        user_inputs: Dict mapping variable URIs to concrete data
                    (only for variables that are plan inputs, not intermediate)
    
    Returns:
        Complete RDF graph with all activities and entities
    """
    g = Graph()
    template = load_template(plan_uri)
    
    # 1. Determine step execution order using topological sort
    steps_ordered = topological_sort_steps(template, plan_uri)
    
    # 2. Track generated entities for data flow
    generated_entities = {}  # variable_uri -> entity_uri
    
    # 3. Execute each step in order
    for step_uri in steps_ordered:
        # Create activity
        activity_uri = create_activity_uri(step_uri)
        
        # Link to template
        g.add((activity_uri, RDF.type, PROV.Activity))
        g.add((activity_uri, PROV.hadPlan, plan_uri))
        g.add((activity_uri, P_PLAN.correspondsToStep, step_uri))
        
        # Inherit resources from step (Rule 2)
        for resource in template.objects(step_uri, PROV.used):
            g.add((activity_uri, PROV.used, resource))
        
        # Get agent from step
        agent = template.value(step_uri, PROV.wasAssociatedWith)
        if agent:
            g.add((activity_uri, PROV.wasAssociatedWith, agent))
        
        # Collect inputs (Rule 3)
        input_entities = {}
        previous_activity = None
        
        for input_var in template.subjects(P_PLAN.isInputVarOf, step_uri):
            # Check if this is intermediate data
            previous_step = template.value(input_var, P_PLAN.isOutputVarOf)
            
            if previous_step and previous_step != step_uri:
                # Intermediate data - use entity from previous step
                entity_uri = generated_entities[str(input_var)]
                input_entities[str(input_var)] = entity_uri
                g.add((activity_uri, PROV.used, entity_uri))
                
                # Link activities
                previous_activity = find_activity_for_step(previous_step)
                g.add((activity_uri, PROV.wasInformedBy, previous_activity))
            else:
                # Workflow input - use user-provided data
                if str(input_var) in user_inputs:
                    entity_data = user_inputs[str(input_var)]
                    entity_uri = create_input_entity(input_var, entity_data)
                    input_entities[str(input_var)] = entity_uri
                    g.add((activity_uri, PROV.used, entity_uri))
        
        # Execute step logic (calls Python script)
        output_entities = execute_step(step_uri, activity_uri, input_entities)
        
        # Store outputs for next steps (Rule 4)
        for output_var in template.subjects(P_PLAN.isOutputVarOf, step_uri):
            if str(output_var) in output_entities:
                generated_entities[str(output_var)] = output_entities[str(output_var)]
    
    return g


def topological_sort_steps(template, plan_uri):
    """
    Order steps based on data dependencies.
    Uses the fact that shared variables create dependencies.
    """
    steps = list(template.subjects(P_PLAN.isStepOfPlan, plan_uri))
    
    # Build dependency graph
    depends_on = {step: set() for step in steps}
    
    for step in steps:
        for input_var in template.subjects(P_PLAN.isInputVarOf, step):
            producer_step = template.value(input_var, P_PLAN.isOutputVarOf)
            if producer_step and producer_step in steps and producer_step != step:
                depends_on[step].add(producer_step)
    
    # Topological sort using Kahn's algorithm
    sorted_steps = []
    no_deps = [s for s in steps if len(depends_on[s]) == 0]
    
    while no_deps:
        step = no_deps.pop(0)
        sorted_steps.append(step)
        
        # Remove this step from others' dependencies
        for other_step in steps:
            if step in depends_on[other_step]:
                depends_on[other_step].remove(step)
                if len(depends_on[other_step]) == 0:
                    no_deps.append(other_step)
    
    if len(sorted_steps) != len(steps):
        raise Exception("Circular dependency detected in workflow")
    
    return sorted_steps
```

## SPARQL Query: Generic Data Flow Trace

This query works for **any** workflow:

```sparql
PREFIX p-plan: <http://purl.org/net/p-plan#>
PREFIX prov: <http://www.w3.org/ns/prov#>

# Trace complete data flow for any workflow execution
SELECT ?stepNum ?step ?activity ?inputVar ?inputEntity ?outputVar ?outputEntity
WHERE {
    # Find all activities for this plan
    ?activity prov:hadPlan ?plan ;
              p-plan:correspondsToStep ?step .
    
    # Find inputs
    OPTIONAL {
        ?activity prov:used ?inputEntity .
        ?inputEntity p-plan:correspondsToVariable ?inputVar .
        ?inputVar p-plan:isInputVarOf ?step .
    }
    
    # Find outputs
    OPTIONAL {
        ?outputEntity prov:wasGeneratedBy ?activity ;
                      p-plan:correspondsToVariable ?outputVar .
        ?outputVar p-plan:isOutputVarOf ?step .
    }
    
    # Determine step order by checking dependencies
    OPTIONAL {
        ?dependsOnActivity prov:hadPlan ?plan .
        ?activity prov:wasInformedBy ?dependsOnActivity .
    }
    
    BIND(COUNT(?dependsOnActivity) AS ?stepNum)
}
ORDER BY ?stepNum ?step
```

## Validation Rules

### Validate Template Structure

```sparql
PREFIX p-plan: <http://purl.org/net/p-plan#>
PREFIX prov: <http://www.w3.org/ns/prov#>

# Check 1: All steps have code and requirements
SELECT ?step WHERE {
    ?step p-plan:isStepOfPlan ?plan .
    FILTER NOT EXISTS {
        ?step prov:used ?code .
        ?code a schema:SoftwareSourceCode .
    }
}
# Should return empty

# Check 2: All intermediate variables connect exactly one output to one or more inputs
SELECT ?var (COUNT(DISTINCT ?outputStep) AS ?outputs) WHERE {
    ?var p-plan:isOutputVarOf ?outputStep ;
         p-plan:isInputVarOf ?inputStep .
    FILTER(?outputStep != ?inputStep)
}
GROUP BY ?var
HAVING(?outputs != 1)
# Should return empty

# Check 3: No circular dependencies
# (Detected during topological sort)
```

### Validate Execution Instance

```sparql
PREFIX p-plan: <http://purl.org/net/p-plan#>
PREFIX prov: <http://www.w3.org/ns/prov#>

# Check 1: All activities inherit step resources
SELECT ?activity ?step ?resource WHERE {
    ?activity p-plan:correspondsToStep ?step .
    ?step prov:used ?resource .
    FILTER NOT EXISTS {
        ?activity prov:used ?resource .
    }
}
# Should return empty

# Check 2: All intermediate data flows correctly
SELECT ?var ?producerActivity ?consumerActivity WHERE {
    # Variable is output of one step and input of another
    ?var p-plan:isOutputVarOf ?producerStep ;
         p-plan:isInputVarOf ?consumerStep .
    FILTER(?producerStep != ?consumerStep)
    
    # Find activities
    ?producerActivity p-plan:correspondsToStep ?producerStep .
    ?consumerActivity p-plan:correspondsToStep ?consumerStep .
    
    # Check if entity exists
    FILTER NOT EXISTS {
        ?entity prov:wasGeneratedBy ?producerActivity ;
                p-plan:correspondsToVariable ?var .
        ?consumerActivity prov:used ?entity .
    }
}
# Should return empty
```

## Example: Applying to CSVW Workflow

### Template (from catalog.ttl):
```turtle
spw:LoadedColumnData a p-plan:Variable ;
    p-plan:isOutputVarOf spw:LoadCSVWColumnStep ;   # Output of Step 1
    p-plan:isInputVarOf spw:CalculateAverageStep .  # Input of Step 2
```

### Automatic Derivation:

1. **Step Order**: 
   - Query finds `LoadedColumnData` is output of `LoadCSVWColumnStep` and input of `CalculateAverageStep`
   - Therefore: `LoadCSVWColumnStep` MUST execute before `CalculateAverageStep`

2. **Data Flow**:
   - Entity generated by Activity 1 (that `correspondsToVariable` `LoadedColumnData`)
   - Automatically becomes input to Activity 2 via `prov:used`

3. **Activity Linking**:
   - Activity 2 gets `prov:wasInformedBy` pointing to Activity 1

**All derived automatically from the template!**

## Benefits of This Approach

1. **Template Agnostic**: Works for 1-step, 2-step, or N-step workflows
2. **Automatic Ordering**: Step execution order derived from data dependencies
3. **Type Safe**: Variable types guide data validation
4. **Provenance Complete**: Full PROV-O chain automatically maintained
5. **Standards Compliant**: Pure P-Plan and PROV-O, no custom extensions needed

## Summary

The key insight is that **P-Plan variables that are both outputs and inputs create the workflow structure**. By using standard P-Plan properties:

- `p-plan:isOutputVarOf` - marks variable as step output
- `p-plan:isInputVarOf` - marks variable as step input
- When the SAME variable has both properties on DIFFERENT steps: automatic data flow

This pattern scales to any number of steps and requires no workflow-specific code.
